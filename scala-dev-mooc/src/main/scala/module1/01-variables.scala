package module1

object variables {


  /** 1. SBT project structure
   *
   *  scala-dev/
   *  --src
   *    --main
   *      --scala
   *   build.sbt
   */



  /**
   *  1. Scala ООП язык, т.к. каждое значение в Scala это объект
   *  2. Scala  ФП язык, т.к. каждая функция в Scala это значение
   *  3. Scala ф-ция это объект
   */





  /**
   * Переменные
   *  val - ключевое слово, с помощью которого мы объявляем иммутабельные переменные.
   *  Раз инициализированна, больше изменить нельзя. Однако, важно понимать, что это не мешает иммутабельной переменной
   *  ссылаться на мутабельный объект
   *
   *  var - ключевое слово, с помощью которого мы объявляем мутабельные переменные.
   *  Значения таких переменных можно изменять.
   *
   *  lazy val - с помощью ключевого слова lazy мы откладываем инициализацию до первого обращения
   */




  /**
   * Block expression {}
   * С помощью фигурных скобок, мы можем выделять блоки кода и присваивать их в переменные.
   * При этом тип переменной, будет равен типу последнего выражения в блоке кода, а ее значение - его значению.
   */

   val x: Int = {
     val y = 1 + 1
     y * 2 // Тип у x будет Int, а значение 4
   }





  /**
   * Управляющие конструкции
   *   if / else
   *   while / do while
   *   for
   */

  /**
   *  Конструкция if / else имеет туже семантику, что и в других ЯП. В зависимости от условия, выполняется либо одна либо
   *  другая ветка.
   *  При этом тип и значение if / else выражения определяется также, как и для блока кода.
   *  Т.е. последним выражением в исполняемой ветке.
   *
   *  ! Если ветки выражения имеют разный тип, то будет взят ближайший общий предок для выражений
    */

  val b1: String = if(1 == 1) "yes" else "no"

  val b2: String = if(1 == 1) {
    println("yes")
    "yes"
  } else {
    println("no")
    "no"
  }

  val b3: Any = if(1 == 1) {
    println("yes")
    "yes"
  } else {
    println("no")
    1
  }

  /**
   * циклы while / do while
   * Повторяют выполнение своего тела, пока условие истинно. Подразумевают наличие side effect.
   * Отличаются моментом, когда происходит проверка условия ДО или ПОСЛЕ выполнения тела цикла
   */

   var condition = true
   var i = 0

   while(condition){
     i += 1
     println(s"I'm running: $i")
   }

   do {
     i += 1
     println(s"I'm running: $i")
   } while (condition)

  /**
   * цикл for позволяет итерироваться по коллекциям, имеет своеобразный синтаксис с обратной стрелочкой
   */

   val seq = List[Int](1, 2, 3)

   for(elem <- seq){
     println(elem)
   }



}
